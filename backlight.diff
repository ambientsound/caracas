diff --git a/ansible/caracas/tasks/raspberrypi.yml b/ansible/caracas/tasks/raspberrypi.yml
index 1d95791..4130541 100644
--- a/ansible/caracas/tasks/raspberrypi.yml
+++ b/ansible/caracas/tasks/raspberrypi.yml
@@ -37,6 +37,14 @@
     - make
     - make install
 
+- name: compile and install backlightd
+  command: "{{item}}"
+  args:
+    chdir: /usr/local/lib/caracas/daemons/backlightd
+  with_items:
+    - make
+    - make install
+
 - name: run the suicide program when shutting down
   file: dest=/lib/systemd/system-shutdown/suicide
         src=/usr/local/lib/caracas/bin/suicide
diff --git a/ansible/caracas/vars/main.yml b/ansible/caracas/vars/main.yml
index 2e16ede..816b779 100644
--- a/ansible/caracas/vars/main.yml
+++ b/ansible/caracas/vars/main.yml
@@ -2,6 +2,7 @@
 
 caracas_systemd_services:
   - amplifier.service
+  - backlightd.service
   - card.service
   - cmpd.service
   - gpslog.service
diff --git a/daemons/backlightd/.gitignore b/daemons/backlightd/.gitignore
new file mode 100644
index 0000000..1524dfe
--- /dev/null
+++ b/daemons/backlightd/.gitignore
@@ -0,0 +1 @@
+backlightd
diff --git a/daemons/backlightd/Makefile b/daemons/backlightd/Makefile
new file mode 100644
index 0000000..d310fda
--- /dev/null
+++ b/daemons/backlightd/Makefile
@@ -0,0 +1,10 @@
+all: backlightd
+
+backlightd: backlightd.c
+	gcc -O2 -o backlightd backlightd.c -lwiringPi -lpthread -lzmq
+
+clean:
+	rm -f backlightd
+
+install:
+	install backlightd /usr/local/bin/backlightd
diff --git a/daemons/backlightd/backlightd.c b/daemons/backlightd/backlightd.c
new file mode 100644
index 0000000..c0c20dd
--- /dev/null
+++ b/daemons/backlightd/backlightd.c
@@ -0,0 +1,215 @@
+/**
+ * Hardware event daemon for the CARACAS project.
+ *
+ * Monitors the Raspberry Pi's GPIO pins and uses Ã˜MQ to emit events
+ * when something happens.
+ *
+ * Requires the wiringPi library.
+ */
+
+#include <assert.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <signal.h>
+#include <wiringPi.h>
+#include <mcp3004.h>
+#include <zmq.h>
+#include <syslog.h>
+
+/**
+ * Type definitions
+ */
+typedef signed char         int8_t;
+typedef unsigned char       uint8_t;
+typedef unsigned short      uint16_t;
+
+/**
+ * Pulse width modulation output pin for Adafruit display backlight regulation.
+ */
+#define PIN_BACKLIGHT_PWM   29  /* BCM_GPIO pin 21, physical pin 40 */
+
+/**
+ * Set the range of the PWM pin to 0-100. That means steps in increments of
+ * 10Hz are possible, from 0-1kHz. The screen is initialized with full intensity.
+ */
+#define PWM_INITIAL_VALUE   100
+#define PWM_RANGE           100
+
+/**
+ * The string that starts a backlight adjustment command.
+ */
+#define BACKLIGHT_CMD       "BACKLIGHT "
+
+/**
+ * Exit codes
+ */
+#define EXIT_ZMQ            1
+#define EXIT_WIRING         2
+#define EXIT_SPI            3
+
+/**
+ * Program options
+ */
+struct opts_t {
+    int running;
+};
+
+struct opts_t opts;
+
+/**
+ * ZeroMQ globals
+ */
+void *zmq_context;
+void *zmq_publisher;
+void *zmq_sock;
+
+/**
+ * Initialize PWM output pin.
+ */
+static void init_pin()
+{
+    softPwmCreate(PIN_BACKLIGHT_PWM, PWM_INITIAL_VALUE, PWM_RANGE);
+}
+
+/**
+ * Convert a intensity percentage to a PWM value.
+ */
+static uint16_t percentage_to_value(uint16_t percentage)
+{
+    return (percentage / 100.0) * PWM_RANGE;
+}
+
+/**
+ * Returns a percentage value from a ZeroMQ message, or -1 if the message is invalid.
+ */
+static int16_t percentage_from_message(const char * msg)
+{
+    msg += strlen(BACKLIGHT_CMD);
+    return atoi(msg);
+}
+
+/**
+ * Send an event using ZeroMQ, and log the output.
+ */
+static int log_zmq_send(void *socket, const char *str)
+{
+    syslog(LOG_INFO, "Publishing ZeroMQ event: %s", str);
+    return zmq_send(socket, str, strlen(str), 0);
+}
+
+/**
+ * Send a normalized ZeroMQ event
+ */
+void simple_zmq_send(const char *source, const char *state)
+{
+    char msg[32];
+
+    sprintf(msg, "%s %s", source, state);
+
+    if (log_zmq_send(zmq_publisher, msg) == -1) {
+        perror("Error when publishing ZeroMQ event");
+    }
+}
+
+/**
+ * Initialize options.
+ */
+static void clear_opts(struct opts_t *o)
+{
+    o->running = 1;
+}
+
+/**
+ * Catch signals from operating system.
+ */
+void signal_handler(int s)
+{
+    syslog(LOG_NOTICE, "Caught signal %d", s);
+    opts.running = 0;
+}
+
+/**
+ * Main program.
+ */
+int main(int argc, char **argv)
+{
+    struct sigaction act;
+    int err;
+    char buf[128];
+    int16_t percentage;
+    uint16_t value;
+
+    openlog("backlightd", LOG_PID, LOG_DAEMON);
+
+    syslog(LOG_INFO, "Starting backlight daemon.");
+
+    /* Create ZeroMQ context */
+    zmq_context = zmq_ctx_new();
+    if (!zmq_context) {
+        syslog(LOG_EMERG, "Failed to create ZeroMQ context: %s", zmq_strerror(errno));
+        return EXIT_FAILURE;
+    }
+
+    /* Create ZeroMQ socket */
+    zmq_sock = zmq_socket(zmq_context, ZMQ_SUB);
+    if (!zmq_sock) {
+        syslog(LOG_EMERG, "Failed to create ZeroMQ socket: %s", zmq_strerror(errno));
+        return EXIT_FAILURE;
+    }
+
+    /* Subscribe to everything */
+    if (zmq_setsockopt(zmq_sock, ZMQ_SUBSCRIBE, BACKLIGHT_CMD, strlen(BACKLIGHT_CMD)) == -1) {
+        syslog(LOG_EMERG, "Failed to set ZeroMQ socket options: %s", zmq_strerror(errno));
+        return EXIT_FAILURE;
+    }
+
+    /* Connect to ZeroMQ publisher */
+    if (zmq_connect(zmq_sock, "tcp://localhost:9090") == -1) {
+        syslog(LOG_EMERG, "Failed to connect to ZeroMQ publisher: %s", zmq_strerror(errno));
+        return EXIT_FAILURE;
+    }
+
+    syslog(LOG_INFO, "Connected to ZeroMQ publisher.");
+
+    if (wiringPiSetup()) {
+        perror("Fatal error: could not initialize wiringPi");
+        return EXIT_WIRING;
+    }
+
+    init_pin();
+
+    act.sa_handler = signal_handler;
+    act.sa_flags = 0;
+    sigemptyset(&act.sa_mask);
+    sigaction(SIGTERM, &act, NULL);
+    sigaction(SIGINT, &act, NULL);
+
+    clear_opts(&opts);
+
+    syslog(LOG_NOTICE, "Backlight daemon started.");
+
+    while (opts.running) {
+        err = zmq_recv(zmq_sock, buf, 128, 0);
+        if (err == -1) {
+            syslog(LOG_ERR, "Failed to receive data from ZeroMQ publisher: %s", zmq_strerror(errno));
+            break;
+        }
+        buf[err] = '\0';
+        syslog(LOG_DEBUG, "Received ZeroMQ message: %s", buf);
+        percentage = percentage_from_message(buf);
+        if (percentage < 0 || percentage > 100) {
+            continue;
+        }
+        value = percentage_to_value(percentage);
+        syslog(LOG_INFO, "Setting backlight to %d%% (value %d)", percentage, value);
+        softPwmWrite(PIN_BACKLIGHT_PWM, value);
+    }
+
+    syslog(LOG_NOTICE, "Received shutdown signal, exiting.");
+
+    zmq_close(zmq_sock);
+    zmq_term(zmq_context);
+
+    return 0;
+}
diff --git a/doc/pins.txt b/doc/pins.txt
index e728bec..7d50254 100644
--- a/doc/pins.txt
+++ b/doc/pins.txt
@@ -8,6 +8,7 @@ GPIO pin usage
 20  GND                         header, rotary click
 22  GPIO25              INPUT   header, rotary click
 24  SPI CS              SPI     board
+40  GPIO29              OUTPUT  display brightness 100Hz 3.3V PWM signal
 
 7   GPCLK0              INPUT   gps, pulse per second
 11  Amplifier power     OUTPUT  board, amplifier power switch
diff --git a/systemd/backlightd.service b/systemd/backlightd.service
new file mode 100644
index 0000000..e2a907d
--- /dev/null
+++ b/systemd/backlightd.service
@@ -0,0 +1,13 @@
+# vi: se ft=systemd:
+
+[Unit]
+Description=Display brightness daemon
+
+[Service]
+ExecStart=/usr/local/bin/backlightd
+Restart=always
+User=root
+Group=root
+
+[Install]
+WantedBy=caracas.target
diff --git a/utils/backlightctl.py b/utils/backlightctl.py
new file mode 100755
index 0000000..7905beb
--- /dev/null
+++ b/utils/backlightctl.py
@@ -0,0 +1,34 @@
+#!/usr/bin/env python2.7
+# coding: utf-8
+
+import time
+import zmq
+import argparse
+
+SOCK = "tcp://localhost:9080"
+CONNECT_TIMEOUT = 0.05
+
+socket = None
+
+
+if __name__ == '__main__':
+    parser = argparse.ArgumentParser()
+    parser.add_argument('value', type=int)
+    args = parser.parse_args()
+
+    # client sanitation, other values will be ignored on the receiver
+    if args.value < 0:
+        args.value = 0
+    elif args.value > 100:
+        args.value = 100
+
+    context = zmq.Context()
+    socket = context.socket(zmq.PUB)
+    socket.connect(SOCK)
+
+    # wait a bit before sending the messages
+    time.sleep(CONNECT_TIMEOUT)
+
+    socket.send_string("BACKLIGHT %d" % args.value)
+    print 'Setting backlight intensity to %d%%' % args.value
+    socket.close()
